<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Registration Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.min.css">
    <style>
       /* Variables for color scheme */
:root {
  --primary-color: #1e88e5;
  --secondary-color: #43a047;
  --accent-color: #fbc02d;
  --background-color: #f0f2f5;
  --card-background: #ffffff;
  --text-color: #333333;
  --muted-color: #777777;
  --shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  --transition-speed: 0.3s;
  --warning-color: #ff9800;
  --error-color: #f44336;
}

/* Global Reset and Body Styling */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Roboto', sans-serif;
  background-color: var(--background-color);
  color: var(--text-color);
  line-height: 1.4; /* Slightly tighter line spacing */
  padding: 15px;    /* Less padding around body */
}

/* Container */
.container {
  max-width: 960px; /* Narrower container for a smaller layout */
  margin: 0 auto;
}

/* Header */
h1 {
  margin-bottom: 15px; /* Reduced spacing below header */
  font-size: 2em;      /* Slightly smaller heading */
  text-align: center;
  color: var(--primary-color);
}

/* File Input Section */
.file-input {
  display: flex;
  gap: 10px;
  justify-content: center;
  margin-bottom: 15px;
}

.file-input input[type="file"] {
  padding: 6px; /* Slightly smaller padding */
  border: 1px solid #ccc;
  border-radius: 4px;
}

/* Stats Container */
.stats-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 15px; /* Slightly smaller gap */
  margin-bottom: 25px;
}

.stat-box {
  background-color: var(--card-background);
  border-radius: 8px;
  padding: 15px;
  text-align: center;
  box-shadow: var(--shadow);
  transition: transform var(--transition-speed);
}

.stat-box:hover {
  transform: translateY(-3px);
}

.stat-number {
  font-size: 2em; /* Reduced from 2.5em to 2em */
  font-weight: bold;
  color: var(--primary-color);
  margin: 10px 0;
}

.stat-label {
  color: var(--muted-color);
  font-size: 0.85em; /* Slightly smaller label text */
}

/* Tabs Container */
.tab-container {
  background-color: var(--card-background);
  border-radius: 8px;
  box-shadow: var(--shadow);
  overflow: hidden;
  margin-bottom: 25px;
}

.tabs {
  display: flex;
  background-color: var(--background-color);
  border-bottom: 1px solid #ddd;
}

.tab {
  flex: 1;
  padding: 10px; /* Reduced padding in tabs */
  text-align: center;
  cursor: pointer;
  transition: background-color var(--transition-speed);
  font-weight: 500;
  color: var(--muted-color);
}

.tab:hover {
  background-color: var(--primary-color);
  color: #fff;
}

.tab.active {
  background-color: var(--primary-color);
  color: #fff;
}

/* Tab Contents */
.tab-content {
  padding: 15px; /* Reduced padding inside tabs */
}

/* Chart Container */
.chart-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.chart-box {
  background-color: var(--card-background);
  border-radius: 8px;
  padding: 15px;
  box-shadow: var(--shadow);
}

.chart-title {
  font-size: 1.1em; /* Slightly smaller chart title */
  margin-bottom: 10px;
  text-align: center;
  color: var(--primary-color);
}

/* Calculator */
.calculator {
  background-color: var(--card-background);
  border-radius: 8px;
  padding: 20px; /* Reduced padding */
  box-shadow: var(--shadow);
  max-width: 450px; /* Slightly smaller width */
  margin: 0 auto;
}

.calculator input {
  width: 100%;
  padding: 8px; /* Reduced input padding */
  margin-bottom: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  transition: border-color var(--transition-speed);
}

.calculator input:focus {
  border-color: var(--primary-color);
  outline: none;
}

.calculator button {
  background-color: var(--primary-color);
  color: #fff;
  border: none;
  padding: 8px 16px; /* Reduced button padding */
  border-radius: 4px;
  cursor: pointer;
  transition: background-color var(--transition-speed);
}

.calculator button:hover {
  background-color: #1565c0;
}

.result {
  margin-top: 15px;
  text-align: center;
}

.result .total {
  font-size: 1.4em; /* Slightly smaller total text */
  color: var(--secondary-color);
  font-weight: bold;
}

.result .breakdown {
  font-size: 0.85em;
  color: var(--muted-color);
}

/* Search */
.search-container {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-bottom: 15px;
}

.search-input {
  flex-grow: 1;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.search-button {
  background-color: var(--primary-color);
  color: #fff;
  border: none;
  padding: 8px 12px; /* Reduced button padding */
  border-radius: 4px;
  cursor: pointer;
  transition: background-color var(--transition-speed);
}

.search-button:hover {
  background-color: #1565c0;
}

/* Registrants Table */
.registrants-table {
  width: 100%;
  border-collapse: collapse;
}

.registrants-table th, 
.registrants-table td {
  padding: 10px;
  border-bottom: 1px solid #e0e0e0;
  text-align: left;
  font-size: 0.9em; /* Slightly smaller table text */
}

.registrants-table th {
  background-color: var(--background-color);
  font-weight: 600;
  position: sticky;
  top: 0;
}

.registrants-table tr:hover {
  background-color: rgba(30, 136, 229, 0.1);
}

/* Highlight */
.highlight {
  background-color: rgba(255, 235, 59, 0.5);
}

/* Registration Order Number */
.order-number {
  font-weight: bold;
  color: var(--primary-color);
}

.date-filter-container {
  background-color: var(--card-background);
  border-radius: 8px;
  box-shadow: var(--shadow);
  padding: 10px;
  margin-bottom: 20px;
}

.date-filter-container h3 {
  margin-top: 0;
  margin-bottom: 8px;
  color: var(--primary-color);
  font-size: 1.1em;
  text-align: center;
}

.date-inputs {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 8px;
  justify-content: center;
  align-items: center;
}

.date-input-group {
  display: flex;
  flex-direction: column;
  min-width: 140px;
}

.date-input-group label {
  margin-bottom: 3px;
  font-size: 0.8em;
  color: var(--muted-color);
}

.date-input-group input {
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.filter-button {
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
  transition: background-color var(--transition-speed);
  align-self: flex-end;
}

.filter-button:hover {
  background-color: #1565c0;
}

.filter-button.secondary {
  background-color: #9e9e9e;
}

.filter-button.secondary:hover {
  background-color: #757575;
}

.date-slider-container {
  margin-top: 3px;
}

.date-range-display {
  text-align: center;
  margin-bottom: 5px;
  font-size: 0.9em;
  color: var(--muted-color);
  padding: 2px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

/* Custom Slider Styling */
#dateSlider {
  margin: 10px 10px;
  height: 4%;
}

#dateSlider .noUi-connect {
  background: var(--primary-color);
}

#dateSlider .noUi-handle {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--primary-color);
  box-shadow: none;
  cursor: pointer;
}

#dateSlider .noUi-handle:before,
#dateSlider .noUi-handle:after {
  display: none;
}

#dateSlider .noUi-tooltip {
  font-size: 0.8em;
  padding: 2px 5px;
}

/* Duplicate Detection Styles */
.duplicate-warning {
  background-color: rgba(255, 152, 0, 0.1);
}

.duplicate-badge {
  display: inline-block;
  background-color: var(--warning-color);
  color: white;
  font-size: 0.7em;
  padding: 2px 5px;
  border-radius: 4px;
  margin-left: 5px;
}

.duplicate-group {
  margin-bottom: 20px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  overflow: hidden;
}

.duplicate-header {
  background-color: rgba(255, 152, 0, 0.2);
  padding: 10px;
  font-weight: bold;
  border-bottom: 1px solid #e0e0e0;
}

.duplicate-reason {
  display: inline-block;
  background-color: rgba(255, 152, 0, 0.8);
  color: white;
  font-size: 0.8em;
  padding: 3px 6px;
  border-radius: 4px;
  margin-left: 8px;
  font-weight: normal;
}
    </style>
</head>
<body>
  <div class="container">
    <h1>Tournament Registration Dashboard</h1>
    
    <div class="file-input">
      <input type="file" id="csvFile" accept=".csv">
      <button onclick="processFile()">Load Data</button>
    </div>
    
    <div class="date-filter-container">
      <h3>Filter by Date Range</h3>
      <div class="date-inputs">
        <div class="date-input-group">
          <label for="startDate">Start Date:</label>
          <input type="date" id="startDate">
        </div>
        <div class="date-input-group">
          <label for="endDate">End Date:</label>
          <input type="date" id="endDate">
        </div>
        <button class="filter-button" onclick="applyDateFilter()">Apply Filter</button>
        <button class="filter-button secondary" onclick="resetDateFilter()">Reset</button>
      </div>
      <div class="date-slider-container">
        <div id="dateRangeDisplay" class="date-range-display">
          <span id="selectedDateRange">No date filter applied</span>
        </div>
        <div id="dateSlider"></div>
      </div>
    </div>

    <div class="stats-container">
      <div class="stat-box">
        <div class="stat-number" id="totalRegistrants">-</div>
        <div class="stat-label">Total Registrants</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="ratedPlayers">-</div>
        <div class="stat-label">Rated Players</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="unratedPlayers">-</div>
        <div class="stat-label">Unrated Players</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="duplicateCount">-</div>
        <div class="stat-label">Potential Duplicates</div>
      </div>
    </div>
    
    <div class="tab-container">
      <div class="tabs">
        <div class="tab active" onclick="showTab('graphs')">Graphs</div>
        <div class="tab" onclick="showTab('registrants')">Registrants</div>
        <div class="tab" onclick="showTab('duplicates')">Duplicates</div>
        <div class="tab" onclick="showTab('calculator')">Revenue Calculator</div>
      </div>
      
      <div id="graphsContent" class="tab-content" style="display: block;">
        <div class="chart-container">
          <div class="chart-box">
            <div class="chart-title">Sections Breakdown</div>
            <canvas id="sectionsChart"></canvas>
          </div>
          <div class="chart-box">
            <div class="chart-title">Rated vs Unrated Players</div>
            <canvas id="ratedUnratedChart"></canvas>
          </div>
        </div>
        
        <div class="chart-box">
          <div class="chart-title">Registration Timeline</div>
          <canvas id="timelineChart"></canvas>
        </div>
      </div>
      
      <div id="registrantsContent" class="tab-content" style="display: none;">
        <div style="padding: 20px;">
          <h2>Registered Players</h2>
          <div class="search-container">
            <input type="text" id="searchInput" class="search-input" placeholder="Search by name, section, CFC ID, or email...">
            <button class="search-button" onclick="searchRegistrants()">Search</button>
            <button class="search-button" onclick="clearSearch()">Clear</button>
          </div>
          <div id="registrantsList"></div>
        </div>
      </div>
      
      <!-- New Duplicates Tab -->
      <div id="duplicatesContent" class="tab-content" style="display: none;">
        <div style="padding: 20px;">
          <h2>Potential Duplicate Registrations</h2>
          <p>The following players appear to have multiple registrations based on matching or similar information.</p>
          <div id="duplicatesList"></div>
        </div>
      </div>
      
      <!-- Calculator Tab -->
      <div id="calculatorContent" class="tab-content" style="display: none;">
        <div class="calculator">
          <h2>Quick Fee &amp; Profit Calculator</h2>
          
          <label for="ratedFee">Fee per Rated Player ($)</label>
          <input type="number" id="ratedFee" value="25">
          
          <label for="unratedFee">Fee per Unrated Player ($)</label>
          <input type="number" id="unratedFee" value="20">
          
          <label for="expensesInput">Total Expenses ($)</label>
          <input type="number" id="expensesInput" value="0">
          
          <button onclick="calculateFees()">Calculate Total</button>
          
          <div class="result">
            <p>Based on current registrations:</p>
            <p>Rated Players: <span id="ratedCount">-</span></p>
            <p>Unrated Players: <span id="unratedCount">-</span></p>
            <p class="total" id="totalRevenue">$0.00</p>
            <p class="breakdown" id="revenueBreakdown"></p>
            <p class="total" id="profitDisplay">Profit: $0.00</p>
          </div>
        </div>
      </div>
    </div>
  </div>

    <script>
        let registrationData = [];
let charts = {};
let filteredData = [];
let dateSlider;
let minDate, maxDate;
let duplicateGroups = []; // Store groups of duplicate registrations

function processFile() {
    const fileInput = document.getElementById('csvFile');
    const file = fileInput.files[0];
    
    if (!file) {
        alert('Please select a CSV file');
        return;
    }
    
    Papa.parse(file, {
        header: true,
        complete: function(results) {
            registrationData = results.data;
            // Remove empty rows
            registrationData = registrationData.filter(row => 
                row["Players Name (Last name, First name)"] &&
                row["Players Name (Last name, First name)"].trim() !== ""
            );
            
            // Sort registrants by timestamp if available
            registrationData.sort((a, b) => {
                const timeA = new Date(a["Timestamp"] || 0);
                const timeB = new Date(b["Timestamp"] || 0);
                return timeA - timeB;
            });
            
            // Add registration order property to each entry
            registrationData.forEach((row, index) => {
                row.registrationOrder = index + 1;
            });
            
            filteredData = [...registrationData];
            
            // Detect duplicates immediately after loading data
            detectDuplicates();
            
            updateDashboard();
            initializeDateSlider();
        }
    });
}

// Initialize date slider based on the data
function initializeDateSlider() {
    // Gather all timestamps from the data
    const timestamps = registrationData
        .map(row => row["Timestamp"])
        .filter(timestamp => timestamp) // Remove undefined/null values
        .map(timestamp => new Date(timestamp));
    
    if (timestamps.length === 0) {
        console.warn("No timestamps found in the data");
        return;
    }
    
    // Find min and max dates
    minDate = new Date(Math.min(...timestamps));
    maxDate = new Date(Math.max(...timestamps));
    
    // Update the date input fields
    document.getElementById('startDate').value = formatDateForInput(minDate);
    document.getElementById('endDate').value = formatDateForInput(maxDate);
    
    // Initialize the slider
    const sliderElement = document.getElementById('dateSlider');
    
    // Check if slider already exists and destroy it
    if (dateSlider) {
        dateSlider.destroy();
    }
    
    // Create slider
    dateSlider = noUiSlider.create(sliderElement, {
        start: [minDate.getTime(), maxDate.getTime()],
        connect: true,
        range: {
            'min': minDate.getTime(),
            'max': maxDate.getTime()
        },
        step: 86400000, // One day in milliseconds
        format: {
            to: function(value) {
                return new Date(value);
            },
            from: function(value) {
                return new Date(value).getTime();
            }
        },
        tooltips: true,
        // Use a custom formatter for the tooltips
        tooltips: {
            to: function(value) {
                return formatDateForDisplay(new Date(value));
            }
        }
    });
    
    // Update the display when the slider changes
    dateSlider.on('update', function(values, handle) {
        const startDate = values[0];
        const endDate = values[1];
        
        document.getElementById('startDate').value = formatDateForInput(startDate);
        document.getElementById('endDate').value = formatDateForInput(endDate);
        
        // Update the display text
        updateDateRangeDisplay(startDate, endDate);
    });
    
    // Initialize the date range display
    updateDateRangeDisplay(minDate, maxDate);
}

// Duplicate Detection Functions
function detectDuplicates() {
    if (!registrationData.length) return;
    
    duplicateGroups = [];
    const processed = new Set(); // Track already processed registrations
    
    // First check for exact matches on CFC ID (for rated players)
    const cfcIdGroups = groupBy(registrationData, row => {
        const cfcId = (row["CFC ID (ONLY if playing in a rated section)"] || "").trim();
        return cfcId ? cfcId : null; // Only group non-empty CFC IDs
    });
    
    // Create duplicate groups from CFC ID matches
    for (const [cfcId, registrations] of Object.entries(cfcIdGroups)) {
        if (cfcId !== "null" && registrations.length > 1) {
            duplicateGroups.push({
                reason: "Same CFC ID",
                registrations: registrations
            });
            
            // Mark these registrations as processed
            registrations.forEach(reg => processed.add(reg.registrationOrder));
        }
    }
    
    // Then check for exact matches on email
    const emailGroups = groupBy(registrationData, row => {
        // Skip if already part of a duplicate group
        if (processed.has(row.registrationOrder)) return null;
        
        const email = (row["Email address (For contact)"] || "").trim().toLowerCase();
        return email ? email : null;
    });
    
    // Create duplicate groups from email matches
    for (const [email, registrations] of Object.entries(emailGroups)) {
        if (email !== "null" && registrations.length > 1) {
            duplicateGroups.push({
                reason: "Same Email",
                registrations: registrations
            });
            
            // Mark these registrations as processed
            registrations.forEach(reg => processed.add(reg.registrationOrder));
        }
    }
    
    // Finally, check for similar names for any remaining registrations
    const remainingRegistrations = registrationData.filter(reg => !processed.has(reg.registrationOrder));
    
    for (let i = 0; i < remainingRegistrations.length; i++) {
        const reg1 = remainingRegistrations[i];
        const name1 = (reg1["Players Name (Last name, First name)"] || "").trim().toLowerCase();
        
        if (!name1) continue;
        
        // Track potential matches for this registration
        const matches = [];
        
        for (let j = i + 1; j < remainingRegistrations.length; j++) {
            const reg2 = remainingRegistrations[j];
            const name2 = (reg2["Players Name (Last name, First name)"] || "").trim().toLowerCase();
            
            if (!name2) continue;
            
            // Check name similarity
            const similarity = calculateNameSimilarity(name1, name2);
            
            // If names are similar enough, consider it a potential duplicate
            if (similarity >= 0.8) { // 80% similarity threshold
                matches.push(reg2);
            }
        }
        
        // If we found matches, create a duplicate group
        if (matches.length > 0) {
            duplicateGroups.push({
                reason: "Similar Names",
                registrations: [reg1, ...matches]
            });
            
            // Mark these registrations as processed
            processed.add(reg1.registrationOrder);
            matches.forEach(reg => processed.add(reg.registrationOrder));
        }
    }
    
    // Update duplicate count in the dashboard
    document.getElementById('duplicateCount').textContent = duplicateGroups.length;
    
    // Update the duplicates list
    updateDuplicatesList();
    
    return duplicateGroups;
}

// Helper function to group registrations by a key
function groupBy(array, keyFunc) {
    return array.reduce((result, item) => {
        const key = keyFunc(item);
        if (key === null) return result; // Skip null keys
        
        if (!result[key]) {
            result[key] = [];
        }
        result[key].push(item);
        return result;
    }, {});
}

// Calculate name similarity (specialized for names)
function calculateNameSimilarity(name1, name2) {
    // Simple case: exact match
    if (name1 === name2) return 1.0;
    
    // Clean and normalize names (remove extra spaces, special characters)
    name1 = name1.replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
    name2 = name2.replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
    
    // Split into words to handle cases where names are in different order
    const words1 = name1.split(' ');
    const words2 = name2.split(' ');
    
    // If one is a subset of the other (e.g., "John Smith" vs "John")
    if (words1.length !== words2.length) {
        // Check if all words in the shorter name appear in the longer name
        const shorter = words1.length < words2.length ? words1 : words2;
        const longer = words1.length < words2.length ? words2 : words1;
        
        const matchCount = shorter.filter(word => 
            longer.some(w => w.toLowerCase() === word.toLowerCase())
        ).length;
        
        if (matchCount === shorter.length) {
            // All words in shorter name match
            return 0.9; // High similarity but not quite exact
        }
    }
    
    // Advanced: use Levenshtein distance for complex cases
    return 1 - calculateLevenshteinDistance(name1, name2) / Math.max(name1.length, name2.length);
}

// Calculate Levenshtein distance
function calculateLevenshteinDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Create the matrix
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Initialize first row and column
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    // Fill the matrix
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            dp[i][j] = Math.min(
                dp[i - 1][j] + 1,      // deletion
                dp[i][j - 1] + 1,      // insertion
                dp[i - 1][j - 1] + cost // substitution
            );
        }
    }
    
    return dp[m][n];
}

// Update the duplicates list display
function updateDuplicatesList() {
    const container = document.getElementById('duplicatesList');
    container.innerHTML = '';
    
    if (duplicateGroups.length === 0) {
        container.innerHTML = '<p>No potential duplicates found.</p>';
        return;
    }
    
    // For each duplicate group
    duplicateGroups.forEach((group, groupIndex) => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'duplicate-group';
        
        // Create header for this group
        const header = document.createElement('div');
        header.className = 'duplicate-header';
        header.textContent = `Duplicate Group ${groupIndex + 1}`;
        
        // Add reason badge
        const reasonSpan = document.createElement('span');
        reasonSpan.className = 'duplicate-reason';
        reasonSpan.textContent = group.reason;
        header.appendChild(reasonSpan);
        
        groupDiv.appendChild(header);
        
        // Create table for this group
        const table = document.createElement('table');
        table.className = 'registrants-table';
        
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const headers = ['#', 'Date/Time', 'Name', 'Section', 'CFC ID', 'Email', 'Phone'];
        
        headers.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');
        
        group.registrations.forEach(registration => {
            const tr = document.createElement('tr');
            tr.className = 'duplicate-warning';
            
            // Add Registration Order Number cell
            const orderNumberTd = document.createElement('td');
            const orderNumber = registration.registrationOrder || 0;
            orderNumberTd.innerHTML = `<span class="order-number">${getOrdinalSuffix(orderNumber)}</span>`;
            
            // Add Date/Time cell
            const timestampTd = document.createElement('td');
            if (registration["Timestamp"]) {
                const timestamp = new Date(registration["Timestamp"]);
                // Format date as MM/DD/YYYY and time as HH:MM:SS
                const dateStr = `${timestamp.getMonth() + 1}/${timestamp.getDate()}/${timestamp.getFullYear()}`;
                const timeStr = timestamp.toTimeString().substring(0, 8);
                timestampTd.textContent = `${dateStr}\n${timeStr}`;
            } else {
                timestampTd.textContent = '-';
            }
            
            const nameTd = document.createElement('td');
            nameTd.textContent = registration["Players Name (Last name, First name)"] || '-';
            
            const sectionTd = document.createElement('td');
            sectionTd.textContent = registration["What section?"] || '-';
            
            const cfcIdTd = document.createElement('td');
            cfcIdTd.textContent = registration["CFC ID (ONLY if playing in a rated section)"] || '-';
            
            const emailTd = document.createElement('td');
            emailTd.textContent = registration["Email address (For contact)"] || '-';
            
            const phoneTd = document.createElement('td');
            phoneTd.textContent = registration["Phone number (optional)"] || '-';
            
            // Add all cells in order
            tr.appendChild(orderNumberTd);
            tr.appendChild(timestampTd);
            tr.appendChild(nameTd);
            tr.appendChild(sectionTd);
            tr.appendChild(cfcIdTd);
            tr.appendChild(emailTd);
            tr.appendChild(phoneTd);
            
            tbody.appendChild(tr);
        });
        
        table.appendChild(tbody);
        groupDiv.appendChild(table);
        container.appendChild(groupDiv);
    });
}

function updateDateRangeDisplay(startDate, endDate) {
    const startStr = formatDateForDisplay(startDate);
    const endStr = formatDateForDisplay(endDate);
    document.getElementById('selectedDateRange').textContent = `${startStr} to ${endStr}`;
}

// Format a date as MM/DD/YYYY for display
function formatDateForDisplay(date) {
    return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
}

// Format a date as YYYY-MM-DD for input fields
function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

function applyDateFilter() {
    const startDateStr = document.getElementById('startDate').value;
    const endDateStr = document.getElementById('endDate').value;
    
    if (!startDateStr || !endDateStr) {
        alert('Please select both start and end dates');
        return;
    }
    
    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);
    
    // Add one day to endDate to include the end date in the filter
    endDate.setDate(endDate.getDate() + 1);
    
    // Update the slider if it exists
    if (dateSlider) {
        dateSlider.set([startDate.getTime(), endDate.getTime()]);
    }
    
    // Filter the data
    filteredData = registrationData.filter(row => {
        if (!row["Timestamp"]) return false;
        
        const rowDate = new Date(row["Timestamp"]);
        return rowDate >= startDate && rowDate < endDate;
    });
    
    updateDashboard();
    updateDateRangeDisplay(startDate, new Date(endDate.getTime() - 86400000)); // Subtract one day for display
}

function resetDateFilter() {
    if (!registrationData.length) return;
    
    // Reset to full date range
    filteredData = [...registrationData];
    
    // Reset date inputs and slider
    if (dateSlider) {
        dateSlider.set([minDate.getTime(), maxDate.getTime()]);
    }
    
    document.getElementById('startDate').value = formatDateForInput(minDate);
    document.getElementById('endDate').value = formatDateForInput(maxDate);
    
    updateDateRangeDisplay(minDate, maxDate);
    updateDashboard();
}

// Helper function to add ordinal suffix to numbers (1st, 2nd, 3rd, etc.)
function getOrdinalSuffix(num) {
    const j = num % 10,
          k = num % 100;
    if (j == 1 && k != 11) {
        return num + "st";
    }
    if (j == 2 && k != 12) {
        return num + "nd";
    }
    if (j == 3 && k != 13) {
        return num + "rd";
    }
    return num + "th";
}

function updateDashboard() {
    updateStats();
    createSectionsChart();
    createRatedUnratedChart();
    createTimelineChart();
    updateRegistrantsList();
    calculateFees();
}

function updateStats() {
    const total = filteredData.length;
    
    const ratedData = filteredData.filter(row => 
        row["What section?"] && row["What section?"].includes("Rated")
    );
    const unratedData = filteredData.filter(row => 
        row["What section?"] && row["What section?"].includes("Unrated")
    );
    
    const rated = ratedData.length;
    const unrated = unratedData.length;
    
    // Calculate most popular section
    const sectionCounts = {};
    filteredData.forEach(row => {
        const section = row["What section?"];
        if (section) {
            sectionCounts[section] = (sectionCounts[section] || 0) + 1;
        }
    });
    
    let mostPopularSection = null;
    let mostPopularCount = 0;
    for (const section in sectionCounts) {
        if (sectionCounts[section] > mostPopularCount) {
            mostPopularCount = sectionCounts[section];
            mostPopularSection = section;
        }
    }
    
    document.getElementById('totalRegistrants').textContent = total;
    document.getElementById('ratedPlayers').textContent = rated;
    document.getElementById('unratedPlayers').textContent = unrated;
    document.getElementById('duplicateCount').textContent = duplicateGroups.length;
    
    // Update counts in fee calculator
    document.getElementById('ratedCount').textContent = rated;
    document.getElementById('unratedCount').textContent = unrated;
}

function createSectionsChart() {
    // Count by section
    const sectionCounts = {};
    filteredData.forEach(row => {
        const section = row["What section?"];
        if (section) {
            sectionCounts[section] = (sectionCounts[section] || 0) + 1;
        }
    });
    
    const labels = Object.keys(sectionCounts);
    const data = Object.values(sectionCounts);
    
    // Generate colors
    const colors = generateColors(labels.length);
    
    const ctx = document.getElementById('sectionsChart').getContext('2d');
    
    if (charts.sectionsChart) {
        charts.sectionsChart.destroy();
    }
    
    // Create labels with counts in brackets
    const labelsWithCounts = labels.map((label, index) => {
        return `${label} (${data[index]})`;
    });
    
    charts.sectionsChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: labelsWithCounts,
            datasets: [{
                data: data,
                backgroundColor: colors,
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: {
                    position: 'right'
                }
            }
        }
    });
}

function createRatedUnratedChart() {
    const ratedCount = filteredData.filter(row => 
        row["What section?"] && row["What section?"].includes("Rated")
    ).length;
    
    const unratedCount = filteredData.filter(row => 
        row["What section?"] && row["What section?"].includes("Unrated")
    ).length;
    
    const ctx = document.getElementById('ratedUnratedChart').getContext('2d');
    
    if (charts.ratedUnratedChart) {
        charts.ratedUnratedChart.destroy();
    }
    
    charts.ratedUnratedChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: ['Rated Players', 'Unrated Players'],
            datasets: [{
                data: [ratedCount, unratedCount],
                backgroundColor: ['#64B5F6', '#FFD54F'],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            cutout: '50%',
            plugins: {
                legend: {
                    position: 'right'
                }
            }
        }
    });
}

function createTimelineChart() {
    // Parse dates and group by day
    const dateMap = {};
    filteredData.forEach(row => {
        const timestamp = row["Timestamp"];
        if (timestamp) {
            // First extract the date part from the timestamp
            // Assuming format like "3/17/2025 10:47:55"
            const dateParts = timestamp.split(' ')[0].split('/');
            if (dateParts.length >= 3) {
                const month = parseInt(dateParts[0]);
                const day = parseInt(dateParts[1]);
                const year = parseInt(dateParts[2]);
                
                // Create a date key in format MM/DD/YYYY
                const dateKey = `${month}/${day}/${year}`;
                dateMap[dateKey] = (dateMap[dateKey] || 0) + 1;
            }
        }
    });
    
    // Sort dates
    const dates = Object.keys(dateMap).sort((a, b) => {
        const partsA = a.split('/').map(Number);
        const partsB = b.split('/').map(Number);
        // Compare years first, then months, then days
        if (partsA[2] !== partsB[2]) return partsA[2] - partsB[2];
        if (partsA[0] !== partsB[0]) return partsA[0] - partsB[0];
        return partsA[1] - partsB[1];
    });
    
    const counts = dates.map(date => dateMap[date]);
    
    // Calculate cumulative registrations
    let cumulative = 0;
    const cumulativeCounts = counts.map(count => {
        cumulative += count;
        return cumulative;
    });
    
    // Format dates for display
    const formattedDates = dates.map(dateStr => {
        const parts = dateStr.split('/');
        return `${parts[0]}/${parts[1]}`;
    });
    
    const ctx = document.getElementById('timelineChart').getContext('2d');
    
    if (charts.timelineChart) {
        charts.timelineChart.destroy();
    }
    
    charts.timelineChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: formattedDates,
            datasets: [
                {
                    label: 'Daily Registrations',
                    data: counts,
                    backgroundColor: '#FF8A80',
                    borderColor: '#FF5252',
                    borderWidth: 1,
                    order: 2
                },
                {
                    label: 'Cumulative Registrations',
                    data: cumulativeCounts,
                    type: 'line',
                    borderColor: '#2196F3',
                    backgroundColor: 'rgba(33, 150, 243, 0.1)',
                    fill: true,
                    tension: 0.4,
                    yAxisID: 'y1',
                    order: 1
                }
            ]
        },
        options: {
            responsive: true,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Daily Count'
                    },
                    beginAtZero: true,
                    position: 'left'
                },
                y1: {
                    title: {
                        display: true,
                        text: 'Cumulative Count'
                    },
                    beginAtZero: true,
                    position: 'right',
                    grid: {
                        drawOnChartArea: false
                    }
                }
            }
        }
    });
}

function updateRegistrantsList() {
    const container = document.getElementById('registrantsList');
    container.innerHTML = '';
    
    // Create a table for the registrants
    const table = document.createElement('table');
    table.className = 'registrants-table';
    
    // Create table header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    // Add Registration # and Date/Time columns to headers
    const headers = ['#', 'Date/Time', 'Name', 'Section', 'CFC ID', 'Email', 'Phone'];
    
    headers.forEach(headerText => {
        const th = document.createElement('th');
        th.textContent = headerText;
        headerRow.appendChild(th);
    });
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Create table body
    const tbody = document.createElement('tbody');
    
    // Create a set of all registration orders that are part of a duplicate group
    const duplicateOrders = new Set();
    duplicateGroups.forEach(group => {
        group.registrations.forEach(reg => {
            duplicateOrders.add(reg.registrationOrder);
        });
    });
    
    filteredData.forEach(row => {
        const tr = document.createElement('tr');
        
        // Check if this row is part of a duplicate pair
        const isDuplicate = duplicateOrders.has(row.registrationOrder);
        
        if (isDuplicate) {
            tr.className = 'duplicate-warning';
        }
        
        // Add Registration Order Number cell
        const orderNumberTd = document.createElement('td');
        const orderNumber = row.registrationOrder || 0;
        orderNumberTd.innerHTML = `<span class="order-number">${getOrdinalSuffix(orderNumber)}</span>`;
        
        // If this is a duplicate, add a badge
        if (isDuplicate) {
            orderNumberTd.innerHTML += `<span class="duplicate-badge">Duplicate</span>`;
        }
        
        // Add Date/Time cell
        const timestampTd = document.createElement('td');
        if (row["Timestamp"]) {
            const timestamp = new Date(row["Timestamp"]);
            // Format date as MM/DD/YYYY and time as HH:MM:SS
            const dateStr = `${timestamp.getMonth() + 1}/${timestamp.getDate()}/${timestamp.getFullYear()}`;
            const timeStr = timestamp.toTimeString().substring(0, 8);
            timestampTd.textContent = `${dateStr}\n${timeStr}`;
        } else {
            timestampTd.textContent = '-';
        }
        
        const nameTd = document.createElement('td');
        nameTd.textContent = row["Players Name (Last name, First name)"];
        
        const sectionTd = document.createElement('td');
        sectionTd.textContent = row["What section?"] || '-';
        
        const cfcIdTd = document.createElement('td');
        cfcIdTd.textContent = row["CFC ID (ONLY if playing in a rated section)"] || '-';
        
        const emailTd = document.createElement('td');
        emailTd.textContent = row["Email address (For contact)"] || '-';
        
        const phoneTd = document.createElement('td');
        phoneTd.textContent = row["Phone number (optional)"] || '-';
        
        // Add all cells in order
        tr.appendChild(orderNumberTd);
        tr.appendChild(timestampTd);
        tr.appendChild(nameTd);
        tr.appendChild(sectionTd);
        tr.appendChild(cfcIdTd);
        tr.appendChild(emailTd);
        tr.appendChild(phoneTd);
        
        tbody.appendChild(tr);
    });
    
    table.appendChild(tbody);
    container.appendChild(table);
}

function calculateFees() {
    const ratedFee = parseFloat(document.getElementById('ratedFee').value) || 0;
    const unratedFee = parseFloat(document.getElementById('unratedFee').value) || 0;
    
    const ratedCount = filteredData.filter(row => 
        row["What section?"] && row["What section?"].includes("Rated")
    ).length;
    
    const unratedCount = filteredData.filter(row => 
        row["What section?"] && row["What section?"].includes("Unrated")
    ).length;
    
    const ratedRevenue = ratedCount * ratedFee;
    const unratedRevenue = unratedCount * unratedFee;
    const totalRevenue = ratedRevenue + unratedRevenue;
    
    // New expense calculation
    const expenses = parseFloat(document.getElementById('expensesInput').value) || 0;
    const profit = totalRevenue - expenses;
    
    document.getElementById('totalRevenue').textContent = `$${totalRevenue.toFixed(2)}`;
    document.getElementById('revenueBreakdown').textContent = 
        `Rated: $${ratedRevenue.toFixed(2)} + Unrated: $${unratedRevenue.toFixed(2)}`;
    document.getElementById('profitDisplay').textContent = `Profit: $${profit.toFixed(2)}`;
}

function showTab(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(content => {
        content.style.display = 'none';
    });
    
    // Show the selected tab content
    document.getElementById(`${tabName}Content`).style.display = 'block';
    
    // Update active tab
    document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Find the clicked tab and add active class
    const tabs = document.querySelectorAll('.tab');
    for (let i = 0; i < tabs.length; i++) {
        if (tabs[i].textContent.toLowerCase().includes(tabName.toLowerCase())) {
            tabs[i].classList.add('active');
            break;
        }
    }
}

function generateColors(count) {
    const colors = [
        '#64B5F6', '#81C784', '#FFB74D', '#E57373', '#9575CD', 
        '#4FC3F7', '#AED581', '#FFD54F', '#FF8A65', '#BA68C8',
        '#4DD0E1', '#DCE775', '#FFB300', '#F06292', '#7986CB'
    ];
    
    // If we need more colors than we have, repeat them
    const result = [];
    for (let i = 0; i < count; i++) {
        result.push(colors[i % colors.length]);
    }
    
    return result;
}

function searchRegistrants() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
    
    if (!searchTerm) {
        filteredData = [...registrationData];
        updateRegistrantsList();
        return;
    }
    
    // Filter data based on search term
    filteredData = registrationData.filter(row => {
        const name = (row["Players Name (Last name, First name)"] || "").toLowerCase();
        const section = (row["What section?"] || "").toLowerCase();
        const cfcId = (row["CFC ID (ONLY if playing in a rated section)"] || "").toLowerCase();
        const email = (row["Email address (For contact)"] || "").toLowerCase();
        const phone = (row["Phone number (optional)"] || "").toLowerCase();
        
        return name.includes(searchTerm) || 
               section.includes(searchTerm) || 
               cfcId.includes(searchTerm) || 
               email.includes(searchTerm) || 
               phone.includes(searchTerm);
    });
    
    updateRegistrantsList();
    
    // Highlight search terms in the results
    if (searchTerm) {
        highlightSearchTerm(searchTerm);
    }
}

function highlightSearchTerm(term) {
    const table = document.querySelector('.registrants-table');
    if (!table) return;
    
    const rows = table.querySelectorAll('tbody tr');
    
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        
        cells.forEach(cell => {
            const text = cell.textContent;
            if (text.toLowerCase().includes(term.toLowerCase())) {
                // Only highlight the matching part
                const regex = new RegExp('(' + term + ')', 'gi');
                cell.innerHTML = text.replace(regex, '<span class="highlight">$1</span>');
            }
        });
    });
}

function clearSearch() {
    document.getElementById('searchInput').value = '';
    filteredData = [...registrationData];
    updateRegistrantsList();
}

// Add event listener for Enter key on search input
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchRegistrants();
            }
        });
    }
});

// Initialize empty charts
window.onload = function() {
    const ctx1 = document.getElementById('sectionsChart').getContext('2d');
    charts.sectionsChart = new Chart(ctx1, {
        type: 'pie',
        data: {
            labels: [],
            datasets: [{
                data: [],
                backgroundColor: [],
                borderWidth: 1
            }]
        }
    });
    
    const ctx2 = document.getElementById('ratedUnratedChart').getContext('2d');
    charts.ratedUnratedChart = new Chart(ctx2, {
        type: 'doughnut',
        data: {
            labels: ['Rated Players', 'Unrated Players'],
            datasets: [{
                data: [0, 0],
                backgroundColor: ['#64B5F6', '#FFD54F'],
                borderWidth: 1
            }]
        }
    });
    
    const ctx3 = document.getElementById('timelineChart').getContext('2d');
    charts.timelineChart = new Chart(ctx3, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Daily Registrations',
                    data: [],
                    backgroundColor: '#FF8A80',
                    borderWidth: 1
                },
                {
                    label: 'Cumulative Registrations',
                    data: [],
                    type: 'line',
                    borderColor: '#2196F3',
                    backgroundColor: 'rgba(33, 150, 243, 0.1)',
                    fill: true
                }
            ]
        }
    });
};
    </script>
</body>
</html>
